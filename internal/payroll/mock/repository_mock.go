// Code generated by MockGen. DO NOT EDIT.
// Source: internal/payroll/repository.go
//
// Generated by this command:
//
//	mockgen -source internal/payroll/repository.go -destination internal/payroll/mock/repository_mock.go -package=mocks -typed
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	payroll "github.com/vnnyx/employee-management/internal/payroll"
	entity "github.com/vnnyx/employee-management/internal/payroll/entity"
	database "github.com/vnnyx/employee-management/pkg/database"
	gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
	isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// FindPayrollByID mocks base method.
func (m *MockRepository) FindPayrollByID(ctx context.Context, payrollID string) (*entity.Payroll, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindPayrollByID", ctx, payrollID)
	ret0, _ := ret[0].(*entity.Payroll)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindPayrollByID indicates an expected call of FindPayrollByID.
func (mr *MockRepositoryMockRecorder) FindPayrollByID(ctx, payrollID any) *MockRepositoryFindPayrollByIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPayrollByID", reflect.TypeOf((*MockRepository)(nil).FindPayrollByID), ctx, payrollID)
	return &MockRepositoryFindPayrollByIDCall{Call: call}
}

// MockRepositoryFindPayrollByIDCall wrap *gomock.Call
type MockRepositoryFindPayrollByIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFindPayrollByIDCall) Return(arg0 *entity.Payroll, arg1 error) *MockRepositoryFindPayrollByIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFindPayrollByIDCall) Do(f func(context.Context, string) (*entity.Payroll, error)) *MockRepositoryFindPayrollByIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFindPayrollByIDCall) DoAndReturn(f func(context.Context, string) (*entity.Payroll, error)) *MockRepositoryFindPayrollByIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindPayrollByPeriodID mocks base method.
func (m *MockRepository) FindPayrollByPeriodID(ctx context.Context, periodID string, opts ...entity.FindPayrollOptions) (*entity.Payroll, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, periodID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindPayrollByPeriodID", varargs...)
	ret0, _ := ret[0].(*entity.Payroll)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindPayrollByPeriodID indicates an expected call of FindPayrollByPeriodID.
func (mr *MockRepositoryMockRecorder) FindPayrollByPeriodID(ctx, periodID any, opts ...any) *MockRepositoryFindPayrollByPeriodIDCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, periodID}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPayrollByPeriodID", reflect.TypeOf((*MockRepository)(nil).FindPayrollByPeriodID), varargs...)
	return &MockRepositoryFindPayrollByPeriodIDCall{Call: call}
}

// MockRepositoryFindPayrollByPeriodIDCall wrap *gomock.Call
type MockRepositoryFindPayrollByPeriodIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFindPayrollByPeriodIDCall) Return(arg0 *entity.Payroll, arg1 error) *MockRepositoryFindPayrollByPeriodIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFindPayrollByPeriodIDCall) Do(f func(context.Context, string, ...entity.FindPayrollOptions) (*entity.Payroll, error)) *MockRepositoryFindPayrollByPeriodIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFindPayrollByPeriodIDCall) DoAndReturn(f func(context.Context, string, ...entity.FindPayrollOptions) (*entity.Payroll, error)) *MockRepositoryFindPayrollByPeriodIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindPayslipByPayrollID mocks base method.
func (m *MockRepository) FindPayslipByPayrollID(ctx context.Context, payrollID string, opts ...entity.FindPayslipOptions) (entity.FindPayslipResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, payrollID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindPayslipByPayrollID", varargs...)
	ret0, _ := ret[0].(entity.FindPayslipResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindPayslipByPayrollID indicates an expected call of FindPayslipByPayrollID.
func (mr *MockRepositoryMockRecorder) FindPayslipByPayrollID(ctx, payrollID any, opts ...any) *MockRepositoryFindPayslipByPayrollIDCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, payrollID}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPayslipByPayrollID", reflect.TypeOf((*MockRepository)(nil).FindPayslipByPayrollID), varargs...)
	return &MockRepositoryFindPayslipByPayrollIDCall{Call: call}
}

// MockRepositoryFindPayslipByPayrollIDCall wrap *gomock.Call
type MockRepositoryFindPayslipByPayrollIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFindPayslipByPayrollIDCall) Return(arg0 entity.FindPayslipResult, arg1 error) *MockRepositoryFindPayslipByPayrollIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFindPayslipByPayrollIDCall) Do(f func(context.Context, string, ...entity.FindPayslipOptions) (entity.FindPayslipResult, error)) *MockRepositoryFindPayslipByPayrollIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFindPayslipByPayrollIDCall) DoAndReturn(f func(context.Context, string, ...entity.FindPayslipOptions) (entity.FindPayslipResult, error)) *MockRepositoryFindPayslipByPayrollIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindPayslipByUserIDPeriod mocks base method.
func (m *MockRepository) FindPayslipByUserIDPeriod(ctx context.Context, userID, periodID string) (*entity.Payslip, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindPayslipByUserIDPeriod", ctx, userID, periodID)
	ret0, _ := ret[0].(*entity.Payslip)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindPayslipByUserIDPeriod indicates an expected call of FindPayslipByUserIDPeriod.
func (mr *MockRepositoryMockRecorder) FindPayslipByUserIDPeriod(ctx, userID, periodID any) *MockRepositoryFindPayslipByUserIDPeriodCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPayslipByUserIDPeriod", reflect.TypeOf((*MockRepository)(nil).FindPayslipByUserIDPeriod), ctx, userID, periodID)
	return &MockRepositoryFindPayslipByUserIDPeriodCall{Call: call}
}

// MockRepositoryFindPayslipByUserIDPeriodCall wrap *gomock.Call
type MockRepositoryFindPayslipByUserIDPeriodCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFindPayslipByUserIDPeriodCall) Return(arg0 *entity.Payslip, arg1 error) *MockRepositoryFindPayslipByUserIDPeriodCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFindPayslipByUserIDPeriodCall) Do(f func(context.Context, string, string) (*entity.Payslip, error)) *MockRepositoryFindPayslipByUserIDPeriodCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFindPayslipByUserIDPeriodCall) DoAndReturn(f func(context.Context, string, string) (*entity.Payslip, error)) *MockRepositoryFindPayslipByUserIDPeriodCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StoreNewPayroll mocks base method.
func (m *MockRepository) StoreNewPayroll(ctx context.Context, arg1 entity.Payroll) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreNewPayroll", ctx, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreNewPayroll indicates an expected call of StoreNewPayroll.
func (mr *MockRepositoryMockRecorder) StoreNewPayroll(ctx, arg1 any) *MockRepositoryStoreNewPayrollCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreNewPayroll", reflect.TypeOf((*MockRepository)(nil).StoreNewPayroll), ctx, arg1)
	return &MockRepositoryStoreNewPayrollCall{Call: call}
}

// MockRepositoryStoreNewPayrollCall wrap *gomock.Call
type MockRepositoryStoreNewPayrollCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryStoreNewPayrollCall) Return(arg0 error) *MockRepositoryStoreNewPayrollCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryStoreNewPayrollCall) Do(f func(context.Context, entity.Payroll) error) *MockRepositoryStoreNewPayrollCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryStoreNewPayrollCall) DoAndReturn(f func(context.Context, entity.Payroll) error) *MockRepositoryStoreNewPayrollCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StoreNewPayrollSummary mocks base method.
func (m *MockRepository) StoreNewPayrollSummary(ctx context.Context, summary entity.PayrollSummary) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreNewPayrollSummary", ctx, summary)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreNewPayrollSummary indicates an expected call of StoreNewPayrollSummary.
func (mr *MockRepositoryMockRecorder) StoreNewPayrollSummary(ctx, summary any) *MockRepositoryStoreNewPayrollSummaryCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreNewPayrollSummary", reflect.TypeOf((*MockRepository)(nil).StoreNewPayrollSummary), ctx, summary)
	return &MockRepositoryStoreNewPayrollSummaryCall{Call: call}
}

// MockRepositoryStoreNewPayrollSummaryCall wrap *gomock.Call
type MockRepositoryStoreNewPayrollSummaryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryStoreNewPayrollSummaryCall) Return(arg0 error) *MockRepositoryStoreNewPayrollSummaryCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryStoreNewPayrollSummaryCall) Do(f func(context.Context, entity.PayrollSummary) error) *MockRepositoryStoreNewPayrollSummaryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryStoreNewPayrollSummaryCall) DoAndReturn(f func(context.Context, entity.PayrollSummary) error) *MockRepositoryStoreNewPayrollSummaryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StoreNewPayslips mocks base method.
func (m *MockRepository) StoreNewPayslips(ctx context.Context, payslips []entity.Payslip) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreNewPayslips", ctx, payslips)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreNewPayslips indicates an expected call of StoreNewPayslips.
func (mr *MockRepositoryMockRecorder) StoreNewPayslips(ctx, payslips any) *MockRepositoryStoreNewPayslipsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreNewPayslips", reflect.TypeOf((*MockRepository)(nil).StoreNewPayslips), ctx, payslips)
	return &MockRepositoryStoreNewPayslipsCall{Call: call}
}

// MockRepositoryStoreNewPayslipsCall wrap *gomock.Call
type MockRepositoryStoreNewPayslipsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryStoreNewPayslipsCall) Return(arg0 error) *MockRepositoryStoreNewPayslipsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryStoreNewPayslipsCall) Do(f func(context.Context, []entity.Payslip) error) *MockRepositoryStoreNewPayslipsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryStoreNewPayslipsCall) DoAndReturn(f func(context.Context, []entity.Payslip) error) *MockRepositoryStoreNewPayslipsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WithTx mocks base method.
func (m *MockRepository) WithTx(tx database.DBTx) payroll.Repository {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithTx", tx)
	ret0, _ := ret[0].(payroll.Repository)
	return ret0
}

// WithTx indicates an expected call of WithTx.
func (mr *MockRepositoryMockRecorder) WithTx(tx any) *MockRepositoryWithTxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithTx", reflect.TypeOf((*MockRepository)(nil).WithTx), tx)
	return &MockRepositoryWithTxCall{Call: call}
}

// MockRepositoryWithTxCall wrap *gomock.Call
type MockRepositoryWithTxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryWithTxCall) Return(arg0 payroll.Repository) *MockRepositoryWithTxCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryWithTxCall) Do(f func(database.DBTx) payroll.Repository) *MockRepositoryWithTxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryWithTxCall) DoAndReturn(f func(database.DBTx) payroll.Repository) *MockRepositoryWithTxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
